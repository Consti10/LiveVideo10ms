//TODO doesn't work with H265 yet
            AVCodec* avCodec=avcodec_find_decoder(AV_CODEC_ID_H264);
            AVCodecParserContext* avCodecParserContext = av_parser_init(AV_CODEC_ID_H264);
            AVCodecContext* avCodecContext = avcodec_alloc_context3(avCodec);
            AVPacket avPacket;
            av_init_packet(&avPacket);
            auto ret = av_parser_parse2(avCodecParserContext,avCodecContext, &avPacket.data,&avPacket.size,
                                        getData(),getSize(), AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);
            MLOGD<<"Ret:"<<ret<<" "<<getSize();
            MLOGD<<"Codec context W H "<<avCodecContext->width<<" "<<avCodecContext->height;
            MLOGD<<"AVCodec context W H "<<avCodecParserContext->width<<" "<<avCodecParserContext->height;
            avcodec_free_context(&avCodecContext);
            //return {320,240};
            return {640,480};
            //return {180,120};
            h264_stream_t* h = h264_new();
            read_nal_unit(h,getDataWithoutPrefix(),(int)getDataSizeWithoutPrefix());
            sps_t* sps=h->sps;
            int Width = ((sps->pic_width_in_mbs_minus1 +1)*16) -sps->frame_crop_right_offset *2 -sps->frame_crop_left_offset *2;
            int Height = ((2 -sps->frame_mbs_only_flag)* (sps->pic_height_in_map_units_minus1 +1) * 16) - (sps->frame_crop_bottom_offset* 2) - (sps->frame_crop_top_offset* 2);
            h264_free(h);
            return {Width,Height};













//Don't forget to free the h264 stream
    /*h264_stream_t* toH264Stream()const{
        h264_stream_t* h = h264_new();
        read_nal_unit(h,getDataWithoutPrefix(),(int)getDataSizeWithoutPrefix());
        return h;
    }

    void debugX()const{
        h264_stream_t* h = h264_new();
        read_debug_nal_unit(h,getDataWithoutPrefix(),(int)getDataSizeWithoutPrefix());
        h264_free(h);
    }*/

    //Create a NALU from h264stream object
    //Only tested on PSP/PPS !!!!!!!!!!
    //After copying data into the new NALU the h264_stream object is deleted
    //If the oldNALU!=nullptr the function checks if the new created nalu has the exact same length and also uses its creation timestamp
    //Example modifying sps:
    //if(nalu.isSPS()){
    //    h264_stream_t* h=nalu.toH264Stream();
    //    //Do manipulations to h->sps...
    //    modNALU=NALU::fromH264StreamAndFree(h,&nalu);
    //}
    /*static NALU* fromH264StreamAndFree(h264_stream_t* h,const NALU* oldNALU= nullptr){
        //The write function seems to be a bit buggy, e.g. its input buffer size needs to be stupid big
        std::vector<uint8_t> tmp(1024);
        int writeRet=write_nal_unit(h,tmp.data(),1024);
        tmp.insert(tmp.begin(),0);
        tmp.insert(tmp.begin(),0);
        tmp.insert(tmp.begin(),0);
        tmp.at(3)=1;
        writeRet+=3;
        //allocate memory for the new NALU
        uint8_t* newNaluData=new uint8_t[writeRet];
        memcpy(newNaluData,tmp.data(),(size_t)writeRet);
        if(oldNALU!= nullptr){
            if(oldNALU->data.size()!=writeRet){
                __android_log_print(ANDROID_LOG_ERROR,"NALU","Error h264bitstream %d %d",(int)oldNALU->data.size(),writeRet);
            }
            return new NALU(newNaluData,(size_t)writeRet,oldNALU->creationTime);
        }
        return new NALU(newNaluData,(size_t)writeRet);
    }*/