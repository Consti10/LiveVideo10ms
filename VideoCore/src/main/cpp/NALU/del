//TODO doesn't work with H265 yet
            AVCodec* avCodec=avcodec_find_decoder(AV_CODEC_ID_H264);
            AVCodecParserContext* avCodecParserContext = av_parser_init(AV_CODEC_ID_H264);
            AVCodecContext* avCodecContext = avcodec_alloc_context3(avCodec);
            AVPacket avPacket;
            av_init_packet(&avPacket);
            auto ret = av_parser_parse2(avCodecParserContext,avCodecContext, &avPacket.data,&avPacket.size,
                                        getData(),getSize(), AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);
            MLOGD<<"Ret:"<<ret<<" "<<getSize();
            MLOGD<<"Codec context W H "<<avCodecContext->width<<" "<<avCodecContext->height;
            MLOGD<<"AVCodec context W H "<<avCodecParserContext->width<<" "<<avCodecParserContext->height;
            avcodec_free_context(&avCodecContext);
            //return {320,240};
            return {640,480};
            //return {180,120};
            h264_stream_t* h = h264_new();
            read_nal_unit(h,getDataWithoutPrefix(),(int)getDataSizeWithoutPrefix());
            sps_t* sps=h->sps;
            int Width = ((sps->pic_width_in_mbs_minus1 +1)*16) -sps->frame_crop_right_offset *2 -sps->frame_crop_left_offset *2;
            int Height = ((2 -sps->frame_mbs_only_flag)* (sps->pic_height_in_map_units_minus1 +1) * 16) - (sps->frame_crop_bottom_offset* 2) - (sps->frame_crop_top_offset* 2);
            h264_free(h);
            return {Width,Height};













//Don't forget to free the h264 stream
    /*h264_stream_t* toH264Stream()const{
        h264_stream_t* h = h264_new();
        read_nal_unit(h,getDataWithoutPrefix(),(int)getDataSizeWithoutPrefix());
        return h;
    }

    void debugX()const{
        h264_stream_t* h = h264_new();
        read_debug_nal_unit(h,getDataWithoutPrefix(),(int)getDataSizeWithoutPrefix());
        h264_free(h);
    }*/

    //Create a NALU from h264stream object
    //Only tested on PSP/PPS !!!!!!!!!!
    //After copying data into the new NALU the h264_stream object is deleted
    //If the oldNALU!=nullptr the function checks if the new created nalu has the exact same length and also uses its creation timestamp
    //Example modifying sps:
    //if(nalu.isSPS()){
    //    h264_stream_t* h=nalu.toH264Stream();
    //    //Do manipulations to h->sps...
    //    modNALU=NALU::fromH264StreamAndFree(h,&nalu);
    //}
    /*static NALU* fromH264StreamAndFree(h264_stream_t* h,const NALU* oldNALU= nullptr){
        //The write function seems to be a bit buggy, e.g. its input buffer size needs to be stupid big
        std::vector<uint8_t> tmp(1024);
        int writeRet=write_nal_unit(h,tmp.data(),1024);
        tmp.insert(tmp.begin(),0);
        tmp.insert(tmp.begin(),0);
        tmp.insert(tmp.begin(),0);
        tmp.at(3)=1;
        writeRet+=3;
        //allocate memory for the new NALU
        uint8_t* newNaluData=new uint8_t[writeRet];
        memcpy(newNaluData,tmp.data(),(size_t)writeRet);
        if(oldNALU!= nullptr){
            if(oldNALU->data.size()!=writeRet){
                __android_log_print(ANDROID_LOG_ERROR,"NALU","Error h264bitstream %d %d",(int)oldNALU->data.size(),writeRet);
            }
            return new NALU(newNaluData,(size_t)writeRet,oldNALU->creationTime);
        }
        return new NALU(newNaluData,(size_t)writeRet);
    }*/





    struct h265_sps{
            int sps_video_parameter_set_id;
            int sps_max_sub_layers_minus1;
            int sps_temporal_id_nesting_flag;
            // profile_tier_level
            struct profile_tier_level{
                int general_profile_space;
                int general_tier_flag;
                int general_profile_idc;
                std::array<int,32> general_profile_compatibility_flag;
                int general_progressive_source_flag;
                int general_interlaced_source_flag;
                int general_non_packed_constraint_flag;
                int general_frame_only_constraint_flag;
                // weird if else
                int general_level_idc;
                std::vector<int> sub_layer_profile_present_flag{};
                std::vector<int> sub_layer_level_present_flag{};
            };
            profile_tier_level profileTierLevel;
            int sps_seq_parameter_set_id;
            int chroma_format_idc;
            //if( chroma_format_idc = = 3 )
            int _separate_colour_plane_flag;
            int pic_width_in_luma_samples;
            int pic_height_in_luma_samples;
            int conformance_window_flag;
            //if( conformance_window_flag ) {
            int _conf_win_left_offset;
            int _conf_win_right_offset;
            int _conf_win_top_offset;
            int _conf_win_bottom_offset;
            int bit_depth_luma_minus8;
            int bit_depth_chroma_minus8;
            int log2_max_pic_order_cnt_lsb_minus4;
            int sps_sub_layer_ordering_info_present_flag;
            //for( i = ( sps_sub_layer_ordering_info_present_flag ? 0 : sps_max_sub_layers_minus1 );
            //i <= sps_max_sub_layers_minus1; i++ ) {
            std::vector<int> sps_max_dec_pic_buffering_minus1{};
            std::vector<int> sps_max_num_reorder_pics{};
            std::vector<int> sps_max_latency_increase_plus1{};

            int log2_min_luma_coding_block_size_minus3;
            int log2_diff_max_min_luma_coding_block_size;
            int log2_min_luma_transform_block_size_minus2;
            int log2_diff_max_min_luma_transform_block_size;
            int max_transform_hierarchy_depth_inter;
            int max_transform_hierarchy_depth_intra;
            int scaling_list_enabled_flag;
            int amp_enabled_flag;
            int sample_adaptive_offset_enabled_flag;
            int pcm_enabled_flag;
            int num_short_term_ref_pic_sets;
        };
        static void read_h265_profile_tier_level(h265_sps::profile_tier_level& ptl, BitStream& b,int profilePresentFlag,int maxNumSubLayersMinus1){
            if(profilePresentFlag){
                ptl.general_profile_space=b.read_u2();
                ptl.general_tier_flag=b.read_u1();
                ptl.general_profile_idc=b.read_u5();
                for(int j=0;j<32;j++){
                    ptl.general_profile_compatibility_flag[j]=b.read_u1();
                }
                ptl.general_progressive_source_flag=b.read_u1();
                ptl.general_interlaced_source_flag=b.read_u1();
                ptl.general_non_packed_constraint_flag=b.read_u1();
                ptl.general_frame_only_constraint_flag=b.read_u1();
                //TODO
                // skip 43 bits
                b.read_u32();
                b.read_u(11);
                // skip 1 bit
                b.read_u1();
                //
                ptl.general_level_idc=b.read_u8();
                //
                ptl.sub_layer_profile_present_flag.resize(maxNumSubLayersMinus1);
                ptl.sub_layer_level_present_flag.resize(maxNumSubLayersMinus1);
                for(int i=0;i<maxNumSubLayersMinus1;i++){
                    ptl.sub_layer_profile_present_flag[i]=b.read_u1();
                    ptl.sub_layer_level_present_flag[i]=b.read_u1();
                }
            }
        }

        static void read_h265_seq_parameter_set_rbsp(h265_sps& s, BitStream& b){
            memset(&s, 0, sizeof(sps_t));
            s.sps_video_parameter_set_id=b.read_u4();
            s.sps_max_sub_layers_minus1 = b.read_u3();
            s.sps_temporal_id_nesting_flag = b.read_u1();
            read_h265_profile_tier_level(s.profileTierLevel, b, 1, s.sps_max_sub_layers_minus1);
            s.sps_seq_parameter_set_id = b.read_ue();
            s.chroma_format_idc = b.read_ue();
            if(s.chroma_format_idc == 3){
                MLOGD<<"Got separate_colour_plane_flag";
                s._separate_colour_plane_flag=b.read_u1();
            }else{
                s._separate_colour_plane_flag=0;
            }
            s.pic_width_in_luma_samples = b.read_ue();
            s.pic_height_in_luma_samples = b.read_ue();
            s.conformance_window_flag =b.read_u1();
            if(s.conformance_window_flag){
                s._conf_win_left_offset=b.read_ue();
                s._conf_win_right_offset=b.read_ue();
                s._conf_win_top_offset=b.read_ue();
                s._conf_win_bottom_offset=b.read_ue();
            }
            s.bit_depth_luma_minus8 =b.read_ue();
            s.bit_depth_chroma_minus8 = b.read_ue();
            s.log2_max_pic_order_cnt_lsb_minus4 =b.read_ue();
            s.sps_sub_layer_ordering_info_present_flag = b.read_u1();
            //
            s.sps_max_dec_pic_buffering_minus1.resize(s.sps_max_sub_layers_minus1+1);
            s.sps_max_num_reorder_pics.resize(s.sps_max_sub_layers_minus1+1);
            s.sps_max_latency_increase_plus1.resize(s.sps_max_sub_layers_minus1+1);
            for(int i=(s.sps_sub_layer_ordering_info_present_flag ? 0 : s.sps_max_sub_layers_minus1);
                i<=s.sps_max_sub_layers_minus1;i++){
                s.sps_max_dec_pic_buffering_minus1[i]=b.read_ue();
                s.sps_max_num_reorder_pics[i]=b.read_ue();
                s.sps_max_latency_increase_plus1[i]=b.read_ue();
            }
            s.log2_min_luma_coding_block_size_minus3=b.read_ue();
            s.log2_diff_max_min_luma_coding_block_size=b.read_ue();
            s.log2_min_luma_transform_block_size_minus2=b.read_ue();
            s.log2_diff_max_min_luma_transform_block_size=b.read_ue();
            s.scaling_list_enabled_flag=b.read_u1();
        }

        class SPS{
        public:
            nal_unit_header_t nal_header;
            h265_sps parsed;
        public:
            // data buffer= NALU data with prefix
            SPS(const uint8_t* nalu_data,size_t data_len){
                auto rbsp_buf= AnnexBHelper::nalu_annexB_to_rbsp_buff(nalu_data, data_len);
                BitStream b(rbsp_buf);
                nal_header.forbidden_zero_bit=b.read_u1();
                nal_header.nal_unit_type = b.read_u6();
                nal_header.nuh_layer_id=b.read_u6();
                nal_header.nuh_temporal_id_plus1=b.read_u3();
                assert(nal_header.forbidden_zero_bit==0);
                assert(nal_header.nal_unit_type==NALUnitType::H265::NAL_UNIT_SPS);
                read_h265_seq_parameter_set_rbsp(parsed,b);
            }
            std::string lol(){
                std::stringstream ss;
                ss<<"[";
                ss<<"pic_width_in_luma_samples:"<<parsed.pic_width_in_luma_samples<<",";
                ss<<"pic_height_in_luma_samples:"<<parsed.pic_height_in_luma_samples<<",";
                ss<<"]";
                return ss.str();
            }
        };




        /*static std::vector<uint8_t> nalu_annexB_to_rbsp_buff(const std::vector<uint8_t>& naluData){
                int nal_size = naluData.size()-4;
                const uint8_t* nal_data=&naluData[4];
                int rbsp_size=nal_size;
                std::vector<uint8_t> rbsp_buf;
                rbsp_buf.resize(rbsp_size+64);
                int rc = nal_to_rbsp(nal_data, &nal_size, rbsp_buf.data(), &rbsp_size);
                assert(rc>0);
                //MLOGD<<"X "<<rbsp_buf.size()<<" Y"<<rbsp_size;
                //assert(rbsp_buf.size()==rbsp_size);
                rbsp_buf.resize(rbsp_size);
                return rbsp_buf;
            }
            static std::vector<uint8_t> nalu_annexB_to_rbsp_buff(const uint8_t* nalu_data, std::size_t nalu_data_size){
                return nalu_annexB_to_rbsp_buff(std::vector<uint8_t>(nalu_data, nalu_data + nalu_data_size));
            }*/